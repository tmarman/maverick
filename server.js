const { createServer } = require('http')
const { parse } = require('url')
const next = require('next')
const { WebSocketServer } = require('ws')
const { spawn } = require('child_process')

const dev = process.env.NODE_ENV !== 'production'
const hostname = 'localhost'
const port = process.env.PORT || 5001

const app = next({ dev, hostname, port })
const handle = app.getRequestHandler()

// Claude Code session management
class ClaudeCodeSessionManager {
  constructor() {
    this.sessions = new Map()
  }

  createSession(sessionId, userId, options = {}) {
    const workingDir = options.workingDir || process.cwd()
    
    // Create project-specific working directory
    const projectWorkingDir = options.workingDir || `/tmp/maverick/projects/${options.projectId || 'default'}`
    
    // Ensure project directory exists and initialize git
    const fs = require('fs')
    if (!fs.existsSync(projectWorkingDir)) {
      fs.mkdirSync(projectWorkingDir, { recursive: true })
      
      // Initialize git repository for the project
      try {
        const { execSync } = require('child_process')
        execSync('git init', { cwd: projectWorkingDir, stdio: 'ignore' })
        
        // Create project directory structure
        const directories = [
          '.maverick/docs',     // PRDs, specs, principles
          '.maverick/templates', // Document templates
          'design/logos',     // Brand assets
          'design/icons',     // UI icons
          'design/images',    // General images
          'design/mockups',   // UI/UX mockups
          'src',             // Source code
          'src/docs',        // Technical documentation
          'tests',           // Test files
          'scripts',         // Build/deployment scripts
          'config'           // Configuration files
        ]
        
        directories.forEach(dir => {
          fs.mkdirSync(`${projectWorkingDir}/${dir}`, { recursive: true })
        })
        
        // Create project README
        fs.writeFileSync(`${projectWorkingDir}/README.md`, `# Project ${options.projectId}

Generated by Maverick AI Business Incubator

## üöÄ Project Structure

\`\`\`
/.maverick/        # Project management and specifications
  /docs/           # PRDs, technical specs, principles
  /templates/      # Document templates for reuse
/design/           # Visual assets and brand materials
  /logos/          # Company/product logos
  /icons/          # UI icons and symbols
  /images/         # General images and graphics
  /mockups/        # UI/UX design mockups
/src/              # Source code and technical docs
  /docs/           # Technical documentation
/tests/            # Test files and test data
/scripts/          # Build, deployment, and utility scripts
/config/           # Configuration files
\`\`\`

## üìã Getting Started

1. Review the PRD in \`/.maverick/docs/PRD.md\`
2. Check design principles in \`/.maverick/docs/design-principles.md\`
3. Review engineering standards in \`/.maverick/docs/engineering-principles.md\`
4. Start development following the specifications

üöÄ  Built with Maverick Business Incubator
`)

        // Create CLAUDE.md with comprehensive instructions
        fs.writeFileSync(`${projectWorkingDir}/CLAUDE.md`, `# Claude Code Instructions for Project ${options.projectId}

You are working within Maverick's AI Business Incubator system. This project follows a structured approach to business and product development.

## üéØ Project Context

This is a business project created through Maverick's incubator process. You have access to:
- Complete business requirements and specifications
- Design principles and brand guidelines  
- Engineering standards and best practices
- Structured project templates

## üìÅ Project Structure

- \`/.maverick/docs/\` - Business documents (PRDs, specs, principles)
- \`/design/\` - Visual assets (logos, icons, mockups)
- \`/src/\` - Source code and technical documentation
- \`/tests/\` - Test files and test data
- \`/scripts/\` - Build and deployment scripts
- \`/config/\` - Configuration files

## üé® Design & Brand Guidelines

When creating any code or documentation:
- Follow the design principles in \`/.maverick/docs/design-principles.md\`
- Use brand colors and typography consistently
- Ensure all UI follows the established design system
- Reference existing logos and icons in \`/design/\`

## ‚öôÔ∏è Engineering Standards

Adhere to engineering principles defined in \`/.maverick/docs/engineering-principles.md\`:
- Write clean, maintainable, and well-documented code
- Follow established coding standards and patterns
- Implement proper error handling and logging
- Include comprehensive tests for all functionality
- Use the approved tech stack and dependencies

## üìù Documentation Requirements

For every feature or component you create:
- Update relevant documentation in \`/.maverick/docs/\`
- Add inline code comments for complex logic
- Create or update API documentation
- Include usage examples and integration guides

## üöÄ Development Workflow

1. **Planning**: Reference PRD and specifications before coding
2. **Design**: Check design mockups and brand guidelines
3. **Implementation**: Follow engineering principles and standards
4. **Testing**: Write and run comprehensive tests
5. **Documentation**: Update all relevant documentation
6. **Review**: Ensure alignment with business requirements

## üí° Key Principles

- **Business-First**: Every technical decision should support business goals
- **Quality-Focused**: Prioritize maintainable, scalable solutions
- **User-Centric**: Always consider the end user experience
- **Brand-Consistent**: Maintain consistent brand and design language
- **Documentation-Heavy**: Document everything for future team members

## üé™ Maverick Incubator Process

This project is part of Maverick's business incubator. You're not just writing code - you're building a complete business solution that includes:
- Market-validated product requirements
- Professional brand and design system
- Enterprise-ready technical architecture
- Comprehensive documentation and processes
- Scalable business operations

Remember: You're building a business, not just an application.

üöÄ  Maverick Business Incubator
`)

        // Create core business documents
        const projectDocsDir = `${projectWorkingDir}/.maverick/docs`
        
        // PRD Template
        fs.writeFileSync(`${projectDocsDir}/PRD.md`, `# Product Requirements Document
## Project ${options.projectId}

*Generated by Maverick Business Incubator*

---

## üìã Executive Summary

### Problem Statement
*What problem are we solving?*

### Solution Overview  
*How does our product solve this problem?*

### Success Metrics
*How will we measure success?*

---

## üéØ Product Goals & Objectives

### Primary Goals
1. [Goal 1]
2. [Goal 2] 
3. [Goal 3]

### Success Criteria
- [ ] Criteria 1
- [ ] Criteria 2
- [ ] Criteria 3

---

## üë• Target Users & Market

### Primary User Personas
**Persona 1: [Role]**
- Demographics: 
- Pain Points:
- Goals:
- Behaviors:

### Market Size & Opportunity
- Total Addressable Market (TAM):
- Serviceable Addressable Market (SAM):
- Serviceable Obtainable Market (SOM):

---

## ‚≠ê Core Features & Requirements

### Must-Have Features (P0)
1. **[Feature Name]**
   - Description:
   - User Story: As a [user], I want [goal] so that [benefit]
   - Acceptance Criteria:
     - [ ] Criterion 1
     - [ ] Criterion 2

### Nice-to-Have Features (P1) 
1. **[Feature Name]**
   - Description:
   - User Story:
   - Acceptance Criteria:

### Future Considerations (P2)
1. **[Feature Name]**
   - Description:
   - Timeline:

---

## üèóÔ∏è Technical Requirements

### Performance Requirements
- Response time: < [X]ms
- Uptime: [X]%
- Concurrent users: [X]

### Security Requirements
- Authentication: 
- Authorization:
- Data Protection:

### Integration Requirements
- Third-party APIs:
- External systems:
- Data sources:

---

## üìä Analytics & Metrics

### Key Performance Indicators (KPIs)
1. [Metric 1]: [Target]
2. [Metric 2]: [Target]
3. [Metric 3]: [Target]

### User Analytics
- User acquisition metrics
- User engagement metrics  
- User retention metrics

---

## üóìÔ∏è Timeline & Milestones

### Phase 1: MVP (Weeks 1-4)
- [ ] Milestone 1
- [ ] Milestone 2

### Phase 2: Enhancement (Weeks 5-8)
- [ ] Milestone 3
- [ ] Milestone 4

### Phase 3: Scale (Weeks 9-12)
- [ ] Milestone 5
- [ ] Milestone 6

---

## ‚ùì Open Questions & Assumptions

### Assumptions
1. [Assumption 1]
2. [Assumption 2]

### Open Questions
1. [Question 1]?
2. [Question 2]?

### Risks & Mitigation
1. **Risk**: [Risk description]
   - **Mitigation**: [How to address]

---

*Document Version: 1.0*  
*Last Updated: ${new Date().toISOString().split('T')[0]}*  
*üöÄ  Created with Maverick Business Incubator*
`)

        // Design Principles
        fs.writeFileSync(`${projectDocsDir}/design-principles.md`, `# Design Principles
## Project ${options.projectId}

*Maverick Business Incubator Design Standards*

---

## üé® Core Design Philosophy

### Brand Identity
- **Mission**: [Your mission statement]
- **Vision**: [Your vision statement]  
- **Values**: [Core values that drive design decisions]

### Design Pillars
1. **User-Centric**: Every design decision prioritizes user experience
2. **Accessible**: Inclusive design for all users and abilities
3. **Consistent**: Unified visual language across all touchpoints
4. **Scalable**: Design systems that grow with the business

---

## üåà Visual Identity

### Color Palette
**Primary Colors**
- Primary: #[HEX] - Used for main CTAs and brand elements
- Secondary: #[HEX] - Supporting actions and accents
- Tertiary: #[HEX] - Background and subtle elements

**Neutral Colors**
- Black: #000000 - Primary text and high contrast elements
- Dark Gray: #333333 - Secondary text
- Medium Gray: #666666 - Subtle text and borders
- Light Gray: #F5F5F5 - Backgrounds and dividers
- White: #FFFFFF - Main backgrounds

**Status Colors**
- Success: #10B981 - Confirmations and positive actions
- Warning: #F59E0B - Alerts and cautions
- Error: #EF4444 - Errors and destructive actions
- Info: #3B82F6 - Information and links

### Typography
**Primary Font**: [Font Family]
- Headings: Bold, clear hierarchy
- Body Text: Readable, accessible sizing
- Code/Monospace: [Monospace font]

**Font Scale**
- H1: 2.5rem (40px) - Page titles
- H2: 2rem (32px) - Section headers
- H3: 1.5rem (24px) - Subsection headers
- Body: 1rem (16px) - Main content
- Small: 0.875rem (14px) - Meta information

---

## üìê Layout & Spacing

### Grid System
- Base unit: 8px
- Container max-width: 1200px
- Breakpoints:
  - Mobile: < 768px
  - Tablet: 768px - 1024px
  - Desktop: > 1024px

### Spacing Scale
- xs: 4px
- sm: 8px  
- md: 16px
- lg: 24px
- xl: 32px
- 2xl: 48px

---

## üîß Component Standards

### Buttons
- Primary: High contrast, clear CTAs
- Secondary: Supporting actions
- Text: Minimal, link-style actions
- Sizes: sm (32px), md (40px), lg (48px)

### Forms
- Clear labels and helper text
- Consistent input styling
- Proper error states and validation
- Accessible form controls

### Navigation
- Clear hierarchy and organization
- Consistent interaction patterns
- Mobile-responsive design
- Accessible keyboard navigation

---

## üì± Responsive Design

### Mobile-First Approach
- Design for mobile screens first
- Progressive enhancement for larger screens
- Touch-friendly interactive elements
- Optimized performance on mobile devices

### Breakpoint Strategy
- Content-first responsive design
- Flexible grid systems
- Scalable typography
- Adaptive imagery

---

## ‚ôø Accessibility Standards

### WCAG 2.1 AA Compliance
- Color contrast ratios of 4.5:1 minimum
- Keyboard navigation support
- Screen reader compatibility
- Focus indicators for all interactive elements

### Implementation Guidelines
- Semantic HTML structure
- Alt text for all images
- Proper heading hierarchy
- Form labels and error messages

---

## üéØ User Experience Principles

### Usability Heuristics
1. **Visibility**: System status is always clear
2. **Consistency**: Familiar patterns and conventions
3. **User Control**: Users can undo and control their experience
4. **Error Prevention**: Design prevents user errors
5. **Recognition**: Interface elements are recognizable

### Interaction Design
- Immediate feedback for all actions
- Loading states and progress indicators
- Smooth transitions and animations
- Intuitive navigation patterns

---

## üìã Design Review Checklist

### Brand Consistency
- [ ] Follows established color palette
- [ ] Uses approved typography
- [ ] Maintains visual hierarchy
- [ ] Aligns with brand voice and tone

### User Experience  
- [ ] Intuitive and easy to use
- [ ] Accessible to all users
- [ ] Mobile-responsive design
- [ ] Fast loading and performance

### Technical Implementation
- [ ] Design system components used
- [ ] Proper semantic markup
- [ ] Optimized assets and images
- [ ] Cross-browser compatibility

---

*Document Version: 1.0*  
*Last Updated: ${new Date().toISOString().split('T')[0]}*  
*üöÄ  Maverick Business Incubator Design Standards*
`)

        // Engineering Principles
        fs.writeFileSync(`${projectDocsDir}/engineering-principles.md`, `# Engineering Principles
## Project ${options.projectId}

*Maverick Business Incubator Technical Standards*

---

## üèóÔ∏è Core Engineering Philosophy

### Technical Excellence
We build software that is:
- **Reliable**: Works consistently under all conditions
- **Maintainable**: Easy to understand, modify, and extend
- **Scalable**: Handles growth in users, data, and complexity
- **Secure**: Protects user data and system integrity

### Business Alignment
Every technical decision must:
- Support business objectives and user needs
- Consider long-term maintainability and costs
- Enable rapid iteration and deployment
- Provide measurable value to stakeholders

---

## üíª Technology Stack

### Approved Technologies
**Frontend**
- Framework: [e.g., Next.js 15.4, React 18.3]
- Styling: [e.g., Tailwind CSS, CSS Modules]
- State Management: [e.g., Context API, Zustand]
- Build Tools: [e.g., Vite, Webpack]

**Backend**
- Runtime: [e.g., Node.js, Python]
- Framework: [e.g., Express, FastAPI]
- Database: [e.g., PostgreSQL, MongoDB]
- Caching: [e.g., Redis, Memcached]

**Infrastructure**
- Cloud Provider: [e.g., AWS, GCP, Azure]
- Containerization: [e.g., Docker, Kubernetes]
- CI/CD: [e.g., GitHub Actions, GitLab CI]
- Monitoring: [e.g., DataDog, New Relic]

### Technology Decision Criteria
1. **Community Support**: Active community and maintenance
2. **Performance**: Meets application performance requirements
3. **Learning Curve**: Team can effectively use and maintain
4. **Ecosystem**: Good integration with existing tools
5. **Long-term Viability**: Technology will be supported long-term

---

## üèõÔ∏è Architecture Principles

### System Design
1. **Separation of Concerns**: Clear boundaries between components
2. **Single Responsibility**: Each module has one clear purpose  
3. **Dependency Inversion**: Depend on abstractions, not concretions
4. **Fail Fast**: Detect and handle errors as early as possible

### API Design
- RESTful endpoints with consistent naming
- Proper HTTP status codes and error handling
- Comprehensive API documentation
- Versioning strategy for backward compatibility

### Database Design
- Normalized data structure with clear relationships
- Proper indexing for query performance
- Data integrity constraints and validation
- Regular backup and recovery procedures

---

## üìù Code Quality Standards

### Code Style
- Consistent formatting using automated tools (Prettier, ESLint)
- Meaningful variable and function names
- Clear code organization and file structure
- Comprehensive inline documentation

### Code Review Process
1. **Pre-Review**: Author self-reviews changes
2. **Peer Review**: At least one team member reviews
3. **Automated Checks**: All tests and linting pass
4. **Approval**: Changes approved before merging

### Testing Strategy
**Unit Tests** (70% coverage minimum)
- Test individual functions and components
- Mock external dependencies
- Fast execution for rapid feedback

**Integration Tests** (20% coverage)
- Test component interactions
- Database and API integration
- End-to-end user workflows

**End-to-End Tests** (10% coverage)
- Critical user journeys
- Cross-browser compatibility
- Performance benchmarks

---

## üîí Security Standards

### Authentication & Authorization
- Strong password requirements and hashing
- Multi-factor authentication for sensitive operations
- Role-based access control (RBAC)
- Session management and timeout policies

### Data Protection
- Encryption at rest and in transit
- PII data handling and privacy compliance
- Secure data backup and recovery
- Regular security audits and penetration testing

### Infrastructure Security
- Network security and firewall rules
- Regular security updates and patches
- Monitoring and alerting for security events
- Incident response procedures

---

## üìà Performance Standards

### Application Performance
- Page load time: < 2 seconds
- API response time: < 500ms (95th percentile)
- Database query time: < 100ms (average)
- Mobile performance: Lighthouse score > 90

### Scalability Requirements
- Horizontal scaling capabilities
- Database optimization and query tuning
- Caching strategies for frequently accessed data
- CDN integration for static assets

### Monitoring & Alerting
- Application performance monitoring (APM)
- Error tracking and logging
- Infrastructure monitoring and alerts
- User experience monitoring

---

## üöÄ Deployment & Operations

### CI/CD Pipeline
1. **Code Commit**: Developer pushes changes
2. **Automated Testing**: All tests must pass
3. **Build Process**: Application is built and packaged
4. **Deployment**: Automated deployment to staging/production
5. **Monitoring**: Post-deployment health checks

### Environment Management
- **Development**: Local development and testing
- **Staging**: Production-like environment for testing
- **Production**: Live user-facing environment
- **Configuration**: Environment-specific settings

### Release Strategy
- Feature flags for controlled rollouts
- Blue-green deployments for zero downtime
- Rollback procedures for failed deployments
- Release notes and communication

---

## üìä Documentation Requirements

### Code Documentation
- README files for all repositories
- API documentation (OpenAPI/Swagger)
- Architecture decision records (ADRs)
- Inline code comments for complex logic

### Process Documentation
- Development workflow and best practices
- Deployment procedures and runbooks
- Incident response procedures
- Onboarding guides for new team members

---

## üîç Quality Assurance

### Definition of Done
- [ ] Feature requirements implemented
- [ ] Unit tests written and passing
- [ ] Integration tests passing
- [ ] Code reviewed and approved
- [ ] Documentation updated
- [ ] Performance requirements met
- [ ] Security review completed
- [ ] Deployed to staging environment

### Technical Debt Management
- Regular code refactoring sessions
- Technical debt tracking and prioritization
- Performance optimization reviews
- Dependency updates and security patches

---

*Document Version: 1.0*  
*Last Updated: ${new Date().toISOString().split('T')[0]}*  
*üöÄ  Maverick Business Incubator Engineering Standards*
`)

        // Technical Specifications Template
        fs.writeFileSync(`${projectDocsDir}/technical-specifications.md`, `# Technical Specifications
## Project ${options.projectId}

*Maverick Business Incubator Technical Documentation*

---

## üèóÔ∏è System Architecture

### High-Level Architecture
[Architecture diagram and description]

### Component Overview
- **Frontend**: [Technology and structure]
- **Backend**: [API and business logic]
- **Database**: [Data storage and management]
- **Infrastructure**: [Hosting and deployment]

---

## üì° API Specifications

### Endpoints
[API endpoint documentation]

### Authentication
[Authentication methods and security]

### Data Models
[Database schema and relationships]

---

## üîß Technical Implementation

### Development Environment
[Setup and configuration instructions]

### Build Process
[Build and deployment procedures]

### Testing Strategy
[Testing approach and coverage]

---

*üöÄ  Maverick Business Incubator*
`)

        // Create template files
        const templatesDir = `${projectWorkingDir}/.maverick/templates`
        
        fs.writeFileSync(`${templatesDir}/meeting-notes.md`, `# Meeting Notes Template

**Date:** [Date]  
**Attendees:** [List attendees]  
**Meeting Type:** [Standup/Planning/Review/etc.]

## üìã Agenda
1. [Agenda item 1]
2. [Agenda item 2]

## üìù Discussion Points
- [Key discussion point]
- [Decision made]

## ‚úÖ Action Items
- [ ] [Action item] - [Owner] - [Due date]

## üìÖ Next Steps
[What happens next]

*üöÄ  Maverick Business Incubator*
`)

        // Create design placeholders and copy Maverick branding
        const designDirs = ['logos', 'icons', 'images', 'mockups']
        designDirs.forEach(dir => {
          fs.writeFileSync(`${projectWorkingDir}/design/${dir}/.gitkeep`, `# ${dir.charAt(0).toUpperCase() + dir.slice(1)}

This directory contains ${dir} for the project.

*üöÄ  Maverick Business Incubator*
`)
        })
        
        // Copy Maverick logo assets to project
        try {
          const maverickDesignDir = '/Users/tim/dev/square/maverick/public/design'
          if (fs.existsSync(`${maverickDesignDir}/icon.png`)) {
            fs.copyFileSync(`${maverickDesignDir}/icon.png`, `${projectWorkingDir}/design/logos/maverick-icon.png`)
          }
          if (fs.existsSync(`${maverickDesignDir}/textmark.png`)) {
            fs.copyFileSync(`${maverickDesignDir}/textmark.png`, `${projectWorkingDir}/design/logos/maverick-textmark.png`)
          }
        } catch (error) {
          console.warn('Could not copy Maverick branding assets:', error.message)
        }

        // Initial commit with full structure
        execSync('git add .', { cwd: projectWorkingDir, stdio: 'ignore' })
        execSync('git commit -m "Initial project setup with Maverick Incubator structure\\n\\n- Complete project directory structure\\n- Business documentation templates\\n- Design and engineering principles\\n- Claude Code integration instructions\\n\\nüöÄ  Generated with Maverick"', { 
          cwd: projectWorkingDir, 
          stdio: 'ignore' 
        })
      } catch (error) {
        console.warn('Could not initialize git repository:', error.message)
      }
    }
    
    // Spawn Claude Code process in project directory
    const claudeProcess = spawn('claude', ['--no-memory'], {
      cwd: projectWorkingDir,
      stdio: ['pipe', 'pipe', 'pipe'],
      env: {
        ...process.env,
        MAVERICK_PROJECT_ID: options.projectId,
        MAVERICK_USER_ID: userId,
        MAVERICK_WORKING_DIR: projectWorkingDir
      }
    })

    const session = {
      id: sessionId,
      process: claudeProcess,
      userId,
      projectId: options.projectId,
      workingDir,
      createdAt: new Date(),
      lastActivity: new Date()
    }

    this.sessions.set(sessionId, session)

    // Auto-cleanup after inactivity
    const cleanup = () => {
      setTimeout(() => {
        if (this.sessions.has(sessionId)) {
          const currentSession = this.sessions.get(sessionId)
          const inactive = Date.now() - currentSession.lastActivity.getTime()
          if (inactive > 30 * 60 * 1000) { // 30 minutes
            this.terminateSession(sessionId)
          } else {
            cleanup() // Check again later
          }
        }
      }, 5 * 60 * 1000) // Check every 5 minutes
    }
    cleanup()

    return session
  }

  getSession(sessionId) {
    return this.sessions.get(sessionId)
  }

  terminateSession(sessionId) {
    const session = this.sessions.get(sessionId)
    if (session && !session.process.killed) {
      session.process.kill('SIGTERM')
      this.sessions.delete(sessionId)
      return true
    }
    return false
  }

  updateActivity(sessionId) {
    const session = this.sessions.get(sessionId)
    if (session) {
      session.lastActivity = new Date()
    }
  }
}

const sessionManager = new ClaudeCodeSessionManager()

// Import Claude Terminal Manager
const { claudeTerminalManager } = require('./src/lib/claude-terminal-manager.js')

app.prepare().then(async () => {
  // Fire off a non-blocking database warmup call  
  console.log('üî• Starting database warmup in background...')
  setTimeout(async () => {
    try {
      // Simple warmup query - don't wait or block startup
      const { PrismaClient } = await import('@prisma/client')
      const prisma = new PrismaClient()
      await prisma.$queryRaw`SELECT 1 as warmup`
      await prisma.$disconnect()
      console.log('‚úÖ Database warmed up successfully')
    } catch (error) {
      console.log('‚ö†Ô∏è  Database warmup failed:', error.message.substring(0, 100))
      console.log('üìù This is normal if database is not accessible - app will still work')
    }
  }, 1000) // Wait 1 second for server to be ready
  const server = createServer(async (req, res) => {
    try {
      // Log client IP for debugging connection issues
      const clientIP = req.headers['x-forwarded-for'] || 
                       req.headers['x-real-ip'] || 
                       req.connection.remoteAddress || 
                       req.socket.remoteAddress ||
                       (req.connection.socket ? req.connection.socket.remoteAddress : null)
      
      if (req.url.includes('/api/') || req.url === '/') {
        console.log(`[${new Date().toISOString()}] ${req.method} ${req.url} - Client IP: ${clientIP}`)
      }
      
      const parsedUrl = parse(req.url, true)
      await handle(req, res, parsedUrl)
    } catch (err) {
      console.error('Error occurred handling', req.url, err)
      res.statusCode = 500
      res.end('internal server error')
    }
  })

  // Set up WebSocket server for Claude Code integration
  const wss = new WebSocketServer({ 
    server,
    path: '/api/claude-code/ws'
  })

  // Set up WebSocket server for Claude Terminal streaming
  const claudeTerminalWss = new WebSocketServer({
    server,
    path: '/ws/claude-terminal'
  })

  claudeTerminalWss.on('error', (error) => {
    console.error('üí• Claude Terminal WebSocket Server Error:', error)
  })

  wss.on('connection', (ws, request) => {
    const url = new URL(request.url, `http://${request.headers.host}`)
    const sessionId = url.searchParams.get('sessionId')
    const userId = url.searchParams.get('userId')
    const projectId = url.searchParams.get('projectId')
    const workingDir = url.searchParams.get('workingDir')

    // Log WebSocket connection with IP
    const wsClientIP = request.headers['x-forwarded-for'] || 
                       request.headers['x-real-ip'] || 
                       request.connection.remoteAddress || 
                       request.socket.remoteAddress ||
                       (request.connection.socket ? request.connection.socket.remoteAddress : null)

    console.log(`[${new Date().toISOString()}] Claude Code WebSocket connection: ${sessionId} - Client IP: ${wsClientIP}`)

    if (!sessionId || !userId) {
      ws.close(1008, 'Missing required parameters')
      return
    }

    // Create or get existing session
    let session = sessionManager.getSession(sessionId)
    if (!session) {
      session = sessionManager.createSession(sessionId, userId, {
        projectId,
        workingDir: workingDir ? decodeURIComponent(workingDir) : undefined
      })
    }

    // Handle WebSocket messages (user input)
    ws.on('message', (data) => {
      try {
        sessionManager.updateActivity(sessionId)
        const message = JSON.parse(data.toString())
        
        switch (message.type) {
          case 'input':
            if (session.process.stdin && !session.process.killed) {
              session.process.stdin.write(message.data + '\\n')
            }
            break
            
          case 'interrupt':
            if (!session.process.killed) {
              session.process.kill('SIGINT')
            }
            break
            
          case 'ping':
            ws.send(JSON.stringify({ type: 'pong' }))
            break
        }
      } catch (error) {
        console.error('WebSocket message error:', error)
        ws.send(JSON.stringify({
          type: 'error',
          data: `Message processing error: ${error.message}`
        }))
      }
    })

    // Forward Claude Code stdout to WebSocket
    session.process.stdout?.on('data', (data) => {
      if (ws.readyState === ws.OPEN) {
        ws.send(JSON.stringify({
          type: 'output',
          data: data.toString()
        }))
      }
    })

    // Forward Claude Code stderr to WebSocket
    session.process.stderr?.on('data', (data) => {
      if (ws.readyState === ws.OPEN) {
        ws.send(JSON.stringify({
          type: 'error',
          data: data.toString()
        }))
      }
    })

    // Handle Claude Code process exit
    session.process.on('close', (code, signal) => {
      console.log(`Claude Code process closed: ${code}, ${signal}`)
      if (ws.readyState === ws.OPEN) {
        ws.send(JSON.stringify({
          type: 'close',
          code,
          signal
        }))
      }
      sessionManager.terminateSession(sessionId)
      ws.close()
    })

    session.process.on('error', (error) => {
      console.error('Claude Code process error:', error)
      if (ws.readyState === ws.OPEN) {
        ws.send(JSON.stringify({
          type: 'process_error',
          data: error.message
        }))
      }
    })

    // Handle WebSocket close
    ws.on('close', () => {
      console.log(`Claude Code WebSocket closed: ${sessionId}`)
      // Keep the session alive for potential reconnection
      // It will be cleaned up by the inactivity timer
    })

    ws.on('error', (error) => {
      console.error('WebSocket error:', error)
    })

    // Send initial connection confirmation
    ws.send(JSON.stringify({
      type: 'connected',
      sessionId,
      workingDir: session.workingDir
    }))
  })

  // Claude Terminal WebSocket handler
  claudeTerminalWss.on('connection', async (ws, request) => {
    console.log('üîó Claude Terminal WebSocket connection attempt received');
    
    // Send immediate response to test basic connection
    ws.send(JSON.stringify({
      type: 'connected',
      message: 'Claude Terminal WebSocket connected',
      timestamp: new Date().toISOString()
    }))
    
    try {
      const url = new URL(request.url, `http://${request.headers.host}`)
      const userId = url.searchParams.get('userId')
      const projectId = url.searchParams.get('projectId')
      
      console.log('üìã Connection params:', { userId, projectId });

    // Log WebSocket connection
    const wsClientIP = request.headers['x-forwarded-for'] || 
                       request.headers['x-real-ip'] || 
                       request.connection.remoteAddress || 
                       request.socket.remoteAddress ||
                       (request.connection.socket ? request.connection.socket.remoteAddress : null)

    console.log(`[${new Date().toISOString()}] Claude Terminal WebSocket connection - User: ${userId}, Project: ${projectId} - Client IP: ${wsClientIP}`)

    if (!userId) {
      ws.close(1008, 'Missing userId parameter')
      return
    }

    let sessionId = null

    try {
      // Create a new terminal session
      sessionId = await claudeTerminalManager.createSession(userId, projectId)
      console.log(`üîß Created Claude terminal session: ${sessionId}`)

      // Send initial connection confirmation
      ws.send(JSON.stringify({
        type: 'connected',
        sessionId,
        timestamp: new Date().toISOString()
      }))

      // Start Claude Code process
      const processStarted = await claudeTerminalManager.startClaudeProcess(sessionId)
      if (!processStarted) {
        ws.send(JSON.stringify({
          type: 'error',
          data: 'Failed to start Claude Code process',
          timestamp: new Date().toISOString()
        }))
        return
      }

    } catch (error) {
      console.error('Error setting up Claude terminal session:', error)
      ws.send(JSON.stringify({
        type: 'error',
        data: `Setup error: ${error.message}`,
        timestamp: new Date().toISOString()
      }))
      ws.close(1011, 'Internal server error')
      return
    }

    // Handle incoming WebSocket messages
    ws.on('message', async (data) => {
      try {
        const message = JSON.parse(data.toString())
        
        switch (message.type) {
          case 'input':
            if (sessionId && message.data) {
              const success = await claudeTerminalManager.sendInput(sessionId, message.data)
              if (!success) {
                ws.send(JSON.stringify({
                  type: 'error',
                  data: 'Failed to send input to Claude process',
                  timestamp: new Date().toISOString()
                }))
              }
            }
            break
            
          case 'get_history':
            if (sessionId) {
              const history = claudeTerminalManager.getSessionHistory(sessionId)
              ws.send(JSON.stringify({
                type: 'history',
                data: history,
                timestamp: new Date().toISOString()
              }))
            }
            break
            
          case 'ping':
            ws.send(JSON.stringify({ 
              type: 'pong',
              timestamp: new Date().toISOString()
            }))
            break
            
          default:
            ws.send(JSON.stringify({
              type: 'error',
              data: `Unknown message type: ${message.type}`,
              timestamp: new Date().toISOString()
            }))
        }
      } catch (error) {
        console.error('WebSocket message error:', error)
        ws.send(JSON.stringify({
          type: 'error',
          data: `Message processing error: ${error.message}`,
          timestamp: new Date().toISOString()
        }))
      }
    })

    // Set up message forwarding from terminal manager to WebSocket
    if (sessionId && claudeTerminalManager) {
      // Subscribe to terminal messages
      const messageHandler = (message) => {
        if (ws.readyState === ws.OPEN) {
          ws.send(JSON.stringify({
            type: message.type,
            data: message.data,
            timestamp: message.timestamp.toISOString(),
            sessionId: message.sessionId
          }))
        }
      }

      // If the terminal manager supports event subscription, use it
      if (typeof claudeTerminalManager.subscribe === 'function') {
        claudeTerminalManager.subscribe(sessionId, messageHandler)
        
        // Clean up subscription when WebSocket closes
        ws.on('close', () => {
          if (typeof claudeTerminalManager.unsubscribe === 'function') {
            claudeTerminalManager.unsubscribe(sessionId, messageHandler)
          }
        })
      } else {
        // Fallback to periodic checking for now
        const messagePoller = setInterval(() => {
          if (ws.readyState === ws.OPEN && sessionId) {
            const history = claudeTerminalManager.getSessionHistory(sessionId)
            const recentMessages = history.slice(-5) // Last 5 messages
            
            // Send any messages that haven't been sent yet
            recentMessages.forEach(message => {
              if (!message.sent) {
                messageHandler(message)
                message.sent = true // Mark as sent
              }
            })
          } else {
            clearInterval(messagePoller)
          }
        }, 500) // Check every 500ms for better performance

        // Clean up poller when WebSocket closes
        ws.on('close', () => {
          clearInterval(messagePoller)
        })
      }
    }

    // Handle WebSocket close
    ws.on('close', async () => {
      console.log(`üõë Claude Terminal WebSocket closed: ${sessionId}`)
      if (sessionId && claudeTerminalManager) {
        // Keep session alive for potential reconnection
        // It will be cleaned up by the terminal manager's cleanup process
      }
    })

    ws.on('error', (error) => {
      console.error('Claude Terminal WebSocket error:', error)
      if (sessionId && claudeTerminalManager) {
        claudeTerminalManager.closeSession(sessionId)
      }
    })
    
    } catch (error) {
      console.error('üí• Error in Claude Terminal WebSocket handler:', error)
      ws.close(1011, `Server error: ${error.message}`)
    }
  })

  server.listen(port, (err) => {
    if (err) throw err
    console.log(`> Ready on http://${hostname}:${port}`)
    console.log(`> Claude Code WebSocket available at ws://${hostname}:${port}/api/claude-code/ws`)
    console.log(`> Claude Terminal WebSocket available at ws://${hostname}:${port}/ws/claude-terminal`)
    
    // Get external IP to help debug VPN issues
    const https = require('https')
    const getExternalIP = () => {
      https.get('https://api.ipify.org?format=json', (res) => {
        let data = ''
        res.on('data', (chunk) => data += chunk)
        res.on('end', () => {
          try {
            const { ip } = JSON.parse(data)
            console.log(`> External IP: ${ip}`)
            
            // Also check if it's a VPN by looking at known VPN providers
            https.get(`https://ipapi.co/${ip}/json/`, (res2) => {
              let ipData = ''
              res2.on('data', (chunk) => ipData += chunk)
              res2.on('end', () => {
                try {
                  const ipInfo = JSON.parse(ipData)
                  console.log(`> IP Location: ${ipInfo.city}, ${ipInfo.region}, ${ipInfo.country_name}`)
                  console.log(`> ISP: ${ipInfo.org}`)
                  if (ipInfo.org && (ipInfo.org.toLowerCase().includes('vpn') || 
                                   ipInfo.org.toLowerCase().includes('proxy') ||
                                   ipInfo.org.toLowerCase().includes('cloudflare') ||
                                   ipInfo.org.toLowerCase().includes('digital ocean'))) {
                    console.log('> ‚ö†Ô∏è  Possible VPN/Proxy detected')
                  }
                } catch (e) {
                  console.log('> Could not get IP info')
                }
              })
            }).on('error', () => {})
          } catch (e) {
            console.log('> Could not get external IP')
          }
        })
      }).on('error', () => {
        console.log('> Could not get external IP')
      })
    }
    
    getExternalIP()
    
    // Log local network interfaces
    const os = require('os')
    const networkInterfaces = os.networkInterfaces()
    console.log('> Local network interfaces:')
    Object.keys(networkInterfaces).forEach(interfaceName => {
      const interfaces = networkInterfaces[interfaceName]
      interfaces.forEach(iface => {
        if (iface.family === 'IPv4' && !iface.internal) {
          console.log(`  ${interfaceName}: ${iface.address}`)
        }
      })
    })
  })
})