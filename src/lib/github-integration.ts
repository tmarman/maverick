import { spawn } from 'child_process'
import { promises as fs } from 'fs'
import path from 'path'

export interface GitHubCommitOptions {
  projectId: string
  message: string
  files: string[]
  branchName?: string
  workingDir: string
}

export class GitHubIntegration {
  private workingDir: string

  constructor(workingDir: string = process.cwd()) {
    this.workingDir = workingDir
  }

  /**
   * Initialize a git repository if it doesn't exist
   */
  async initializeRepository(projectDir: string): Promise<void> {
    try {
      await this.executeGitCommand(['init'], projectDir)
      console.log(`Initialized git repository in ${projectDir}`)
    } catch (error) {
      console.error('Failed to initialize git repository:', error)
      throw error
    }
  }

  /**
   * Create a new branch for the generated code
   */
  async createBranch(branchName: string, projectDir: string): Promise<void> {
    try {
      // Check if branch already exists
      const branches = await this.executeGitCommand(['branch', '--list'], projectDir)
      if (branches.includes(branchName)) {
        await this.executeGitCommand(['checkout', branchName], projectDir)
      } else {
        await this.executeGitCommand(['checkout', '-b', branchName], projectDir)
      }
      console.log(`Created/switched to branch: ${branchName}`)
    } catch (error) {
      console.error('Failed to create branch:', error)
      throw error
    }
  }

  /**
   * Stage and commit generated files
   */
  async commitGeneratedCode(options: GitHubCommitOptions): Promise<string> {
    const { projectId, message, files, branchName, workingDir } = options
    const projectDir = path.join(workingDir, projectId)

    try {
      // Ensure project directory exists
      await fs.mkdir(projectDir, { recursive: true })

      // Initialize git if needed
      try {
        await this.executeGitCommand(['status'], projectDir)
      } catch {
        await this.initializeRepository(projectDir)
      }

      // Create feature branch if specified
      if (branchName) {
        await this.createBranch(branchName, projectDir)
      }

      // Stage specific files or all files if none specified
      if (files.length > 0) {
        for (const file of files) {
          await this.executeGitCommand(['add', file], projectDir)
        }
      } else {
        await this.executeGitCommand(['add', '.'], projectDir)
      }

      // Create commit with Maverick signature
      const commitMessage = `${message}

ðŸš€  Generated with Maverick`

      await this.executeGitCommand(['commit', '-m', commitMessage], projectDir)

      // Get the commit hash
      const commitHash = await this.executeGitCommand(['rev-parse', 'HEAD'], projectDir)

      console.log(`Successfully committed code: ${commitHash.trim()}`)
      return commitHash.trim()
    } catch (error) {
      console.error('Failed to commit generated code:', error)
      throw error
    }
  }

  /**
   * Push changes to remote repository
   */
  async pushToRemote(projectDir: string, branchName: string = 'main'): Promise<void> {
    try {
      // Check if remote exists
      const remotes = await this.executeGitCommand(['remote'], projectDir)
      if (!remotes.includes('origin')) {
        throw new Error('No remote origin configured. Please set up a GitHub repository first.')
      }

      await this.executeGitCommand(['push', 'origin', branchName], projectDir)
      console.log(`Successfully pushed to remote: ${branchName}`)
    } catch (error) {
      console.error('Failed to push to remote:', error)
      throw error
    }
  }

  /**
   * Set up remote origin for a project
   */
  async setRemoteOrigin(projectDir: string, repoUrl: string): Promise<void> {
    try {
      // Remove existing origin if it exists
      try {
        await this.executeGitCommand(['remote', 'remove', 'origin'], projectDir)
      } catch {
        // Ignore if origin doesn't exist
      }

      await this.executeGitCommand(['remote', 'add', 'origin', repoUrl], projectDir)
      console.log(`Set remote origin to: ${repoUrl}`)
    } catch (error) {
      console.error('Failed to set remote origin:', error)
      throw error
    }
  }

  /**
   * Create a GitHub repository for a project (requires GitHub CLI)
   */
  async createGitHubRepository(projectName: string, isPrivate: boolean = true): Promise<string> {
    try {
      const visibility = isPrivate ? '--private' : '--public'
      const result = await this.executeCommand('gh', [
        'repo', 'create', projectName,
        visibility,
        '--description', `Generated by Maverick - ${projectName}`,
        '--clone=false'
      ])

      // Extract repository URL from the output
      const repoUrl = `git@github.com:${await this.getGitHubUsername()}/${projectName}.git`
      console.log(`Created GitHub repository: ${repoUrl}`)
      return repoUrl
    } catch (error) {
      console.error('Failed to create GitHub repository:', error)
      throw error
    }
  }

  /**
   * Get current GitHub username
   */
  async getGitHubUsername(): Promise<string> {
    try {
      const result = await this.executeCommand('gh', ['api', 'user', '--jq', '.login'])
      return result.trim()
    } catch (error) {
      console.error('Failed to get GitHub username:', error)
      throw new Error('GitHub CLI not configured. Please run "gh auth login" first.')
    }
  }

  /**
   * Full workflow: Create repo, commit code, and push
   */
  async deployGeneratedCode(options: {
    projectId: string
    projectName: string
    message: string
    files: string[]
    workingDir: string
    createRepo?: boolean
    isPrivate?: boolean
  }): Promise<{ commitHash: string; repoUrl?: string }> {
    const { projectId, projectName, message, files, workingDir, createRepo = false, isPrivate = true } = options
    const projectDir = path.join(workingDir, projectId)

    try {
      let repoUrl: string | undefined

      // Create GitHub repository if requested
      if (createRepo) {
        repoUrl = await this.createGitHubRepository(projectName, isPrivate)
        await this.setRemoteOrigin(projectDir, repoUrl)
      }

      // Commit the generated code
      const commitHash = await this.commitGeneratedCode({
        projectId,
        message,
        files,
        workingDir,
        branchName: 'main'
      })

      // Push to remote if origin is configured
      try {
        await this.pushToRemote(projectDir, 'main')
      } catch (error) {
        console.warn('Could not push to remote:', error)
      }

      return { commitHash, repoUrl }
    } catch (error) {
      console.error('Failed to deploy generated code:', error)
      throw error
    }
  }

  /**
   * Execute git command in a specific directory
   */
  private async executeGitCommand(args: string[], cwd: string): Promise<string> {
    return this.executeCommand('git', args, cwd)
  }

  /**
   * Execute a shell command and return the output
   */
  private async executeCommand(command: string, args: string[], cwd?: string): Promise<string> {
    return new Promise((resolve, reject) => {
      const process = spawn(command, args, {
        cwd: cwd || this.workingDir,
        stdio: ['pipe', 'pipe', 'pipe']
      })

      let stdout = ''
      let stderr = ''

      process.stdout.on('data', (data) => {
        stdout += data.toString()
      })

      process.stderr.on('data', (data) => {
        stderr += data.toString()
      })

      process.on('close', (code) => {
        if (code === 0) {
          resolve(stdout)
        } else {
          reject(new Error(`Command failed: ${command} ${args.join(' ')}\n${stderr}`))
        }
      })

      process.on('error', (error) => {
        reject(error)
      })
    })
  }
}

// Singleton instance
export const gitHubIntegration = new GitHubIntegration()

// Utility functions for API routes
export async function commitGeneratedFiles(
  projectId: string,
  files: string[],
  message: string = 'Generated code from PRD'
): Promise<string> {
  const workingDir = path.join(process.cwd(), 'generated')
  
  return gitHubIntegration.commitGeneratedCode({
    projectId,
    message,
    files,
    workingDir,
    branchName: 'feature/generated-code'
  })
}

export async function setupProjectRepository(
  projectId: string,
  projectName: string
): Promise<string> {
  const workingDir = path.join(process.cwd(), 'generated')
  const result = await gitHubIntegration.deployGeneratedCode({
    projectId,
    projectName,
    message: 'Initial generated code from Maverick PRD',
    files: [],
    workingDir,
    createRepo: true,
    isPrivate: true
  })
  
  return result.repoUrl || ''
}