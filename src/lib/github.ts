import { prisma } from './prisma'

interface GitHubRepo {
  name: string
  full_name: string
  html_url: string
  clone_url: string
  default_branch: string
  private: boolean
}

interface CreateRepoParams {
  name: string
  description?: string
  private?: boolean
  auto_init?: boolean
  gitignore_template?: string
  license_template?: string
}

export class GitHubService {
  private accessToken: string

  constructor(accessToken: string) {
    this.accessToken = accessToken
  }

  // Get user's GitHub profile
  async getProfile() {
    const response = await fetch('https://api.github.com/user', {
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'Accept': 'application/vnd.github.v3+json',
        'User-Agent': 'Maverick-App'
      }
    })

    if (!response.ok) {
      throw new Error(`GitHub API error: ${response.statusText}`)
    }

    return response.json()
  }

  // Create a new repository
  async createRepository(params: CreateRepoParams): Promise<GitHubRepo> {
    const response = await fetch('https://api.github.com/user/repos', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json',
        'User-Agent': 'Maverick-App'
      },
      body: JSON.stringify({
        name: params.name,
        description: params.description || `Generated by Maverick for ${params.name}`,
        private: params.private ?? false,
        auto_init: params.auto_init ?? true,
        gitignore_template: params.gitignore_template || 'Node',
        license_template: params.license_template || 'mit'
      })
    })

    if (!response.ok) {
      const error = await response.json()
      throw new Error(`Failed to create repository: ${error instanceof Error ? error.message : String(error)}`)
    }

    return response.json()
  }

  // Upload files to repository
  async uploadFile(repoName: string, filePath: string, content: string, message: string) {
    const encodedContent = Buffer.from(content).toString('base64')
    
    const response = await fetch(`https://api.github.com/repos/${repoName}/contents/${filePath}`, {
      method: 'PUT',
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json',
        'User-Agent': 'Maverick-App'
      },
      body: JSON.stringify({
        message,
        content: encodedContent
      })
    })

    if (!response.ok) {
      const error = await response.json()
      throw new Error(`Failed to upload file: ${error instanceof Error ? error.message : String(error)}`)
    }

    return response.json()
  }

  // Create multiple files in a repository (batch upload)
  async uploadMultipleFiles(repoName: string, files: Array<{path: string, content: string}>, message: string) {
    const results = []
    
    for (const file of files) {
      try {
        const result = await this.uploadFile(repoName, file.path, file.content, message)
        results.push({ path: file.path, success: true, result })
      } catch (error) {
        results.push({ path: file.path, success: false, error: error instanceof Error ? error.message : String(error) })
      }
    }
    
    return results
  }

  // Set up repository webhooks (for deployment notifications)
  async createWebhook(repoName: string, webhookUrl: string) {
    const response = await fetch(`https://api.github.com/repos/${repoName}/hooks`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json',
        'User-Agent': 'Maverick-App'
      },
      body: JSON.stringify({
        name: 'web',
        active: true,
        events: ['push', 'pull_request'],
        config: {
          url: webhookUrl,
          content_type: 'json',
          insecure_ssl: '0'
        }
      })
    })

    if (!response.ok) {
      const error = await response.json()
      throw new Error(`Failed to create webhook: ${error instanceof Error ? error.message : String(error)}`)
    }

    return response.json()
  }

  // List user's repositories
  async listRepositories() {
    const response = await fetch('https://api.github.com/user/repos?sort=updated&per_page=100', {
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'Accept': 'application/vnd.github.v3+json',
        'User-Agent': 'Maverick-App'
      }
    })

    if (!response.ok) {
      throw new Error(`GitHub API error: ${response.statusText}`)
    }

    return response.json()
  }

  // Check if user has required scopes
  async checkScopes() {
    const response = await fetch('https://api.github.com/user', {
      method: 'HEAD',
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'User-Agent': 'Maverick-App'
      }
    })

    const scopes = response.headers.get('X-OAuth-Scopes')?.split(', ') || []
    
    const requiredScopes = ['repo', 'user:email']
    const hasRequiredScopes = requiredScopes.every(scope => scopes.includes(scope))
    
    return {
      scopes,
      hasRequiredScopes,
      missing: requiredScopes.filter(scope => !scopes.includes(scope))
    }
  }
}

// Helper function to get GitHub service for a user
export async function getGitHubServiceForUser(userId: string): Promise<GitHubService | null> {
  const githubConnection = await prisma.gitHubConnection.findUnique({
    where: { userId }
  })

  if (!githubConnection) {
    return null
  }

  return new GitHubService(githubConnection.accessToken)
}

// Helper function to generate repository name from business name
export function generateRepoName(businessName: string): string {
  return businessName
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '')
    .substring(0, 100) // GitHub repo name limit
}

// Business app generation integration
export async function createBusinessRepository(userId: string, businessName: string, appType: string) {
  const github = await getGitHubServiceForUser(userId)
  
  if (!github) {
    throw new Error('GitHub connection not found for user')
  }

  const repoName = generateRepoName(businessName)
  
  // Create repository
  const repo = await github.createRepository({
    name: repoName,
    description: `${businessName} - ${appType} application generated by Maverick`,
    private: false, // Public by default, can be changed
    auto_init: true,
    gitignore_template: 'Node',
    license_template: 'mit'
  })

  // Upload initial files (will be integrated with app generation)
  const initialFiles = [
    {
      path: 'README.md',
      content: `# ${businessName}\n\n${appType} application generated by Maverick.\n\n## Getting Started\n\n\`\`\`bash\nnpm install\nnpm run dev\n\`\`\``
    },
    {
      path: 'package.json',
      content: JSON.stringify({
        name: repoName,
        version: '1.0.0',
        description: `${businessName} - ${appType} application`,
        main: 'index.js',
        scripts: {
          dev: 'next dev',
          build: 'next build',
          start: 'next start'
        },
        dependencies: {
          next: '^14.0.0',
          react: '^18.0.0',
          'react-dom': '^18.0.0'
        }
      }, null, 2)
    }
  ]

  await github.uploadMultipleFiles(repo.full_name, initialFiles, 'Initial commit from Maverick')

  return {
    repository: repo,
    repoName: repo.full_name,
    url: repo.html_url,
    cloneUrl: repo.clone_url
  }
}